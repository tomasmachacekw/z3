;; shared variable names
(declare-const a Bool)
(declare-const b Bool)
(declare-const c Bool)
(declare-const d Bool)
(declare-const e Bool)
(declare-const f Bool)

;; variables local to A
(declare-const au Bool)
(declare-const av Bool)
(declare-const aw Bool)
(declare-const ax Bool)
(declare-const ay Bool)
(declare-const az Bool)

(declare-const a1 Bool)
(declare-const a2 Bool)
(declare-const a3 Bool)
(declare-const a4 Bool)
(declare-const a5 Bool)
(declare-const a6 Bool)


;; variables local to B
(declare-const bu Bool)
(declare-const bv Bool)
(declare-const bw Bool)
(declare-const bx Bool)
(declare-const by Bool)
(declare-const bz Bool)

(declare-const b1 Bool)
(declare-const b2 Bool)
(declare-const b3 Bool)
(declare-const b4 Bool)
(declare-const b5 Bool)
(declare-const b6 Bool)

;; These examples are generated by swapping the order of the examples of
;; psms_02, so the local variable naming are swapped as well


;; A is not a cube but fully is assigned after unit literals + BCP
;; B is a cube

;; A ^ B is sat
(satmodsat (a b c d) ;; vars
           ;; A
           (and b (not d) bz (not by)
                (or (not b) c bx))
           ;; B
           (and a (not c) ax)
           )

;; A is not a cube and not fully is assigned after BCP, but no conflicts should be found
;; B is a cube

;; A ^ B is sat
(satmodsat (a b c d) ;; vars
           ;; A
           (and b (not d) bz (not by)
                (or (not b) c bx)
                (or bu (not bw))
                (or bu bv)
           )
           ;; B
           (and a b (not c) ax)
           )

;; A is not a cube and not fully is assigned after BCP, and learning may be required
;; B is a cube

;; A ^ B is sat
(satmodsat (a b c d) ;; vars
           ;; A
           (and b (not d) bz (not by)
                (or (not b) c bx)
                (or bu (not bw) bv)
                (or bu bw bv)
                (or (not bw) (not bv))
           )
           ;; B
           (and a b (not c) ax)
)


;; A is not a cube but fully is assigned after BCP, binary clauses
;; B is a cube

;; A ^ B is unsat
(satmodsat (a b c d) ;; vars
           ;; A
           (and (not d)
                (or (not a) (not bx))
                (or bx (not bz))
                (or bz d))
           ;; B
           (and a ax)
           )
;; expected: a


;; A is not a cube but fully is assigned after BCP
;; B is a cube
;; A ^ B is unsat
(satmodsat (a b c d) ;; vars
           ;; A
           (and (not d) bz (not by)
                (or (not a) (not bx) (not b))
                (or bx a (not bz)))
           ;; B
           (and a b (not c) d ax)
           )
;; expected: a && b


;; A is not a cube but fully is assigned after BCP (two unsat cores)
;; B is a cube

;; A ^ B is unsat
(satmodsat (a b c d) ;; vars
           ;; A
           (and (not d) bz bw
                (or (not a) (not bx) (not b))
                (or bx a (not bz))
                (or (not bu) (not a) (not bw))
                (or bu d c))
           ;; B
           (and a b (not c) ax)
           )
;; expected: a && b
;;      opt: a && c && d


;; A is not a cube and not fully is assigned after BCP, learning required
;; B is a cube

;; A ^ B is unsat
(satmodsat (a b c d) ;; vars
           ;; A
           (and
                (or d bx b)
                (or (not bx) (not b) d)
                (or (not b) d a)       ;; b --> a (with d to not have it binary)
                (or (not b) d (not a)) ;; b --> not a
                (or d b)
                ;; useless clauses
                (or bx by)
                (or by a b1))
           ;; B
           (and a b (not c) ax (not d))
           )


;; A is not a cube and unsat but learning required
;; B is a cube

(satmodsat (a b c d) ;; vars
           ;; A
           (and (not d)
                (or d bx b)
                (or (not bx) (not b) d)
                (or (not b) d a)       ;; b --> a (with d to not have it binary)
                (or (not b) d (not a)) ;; b --> not a
                (or d b)
                ;; useless clauses
                (or bx by)
                (or by a b1))
           ;; B
           (and a b (not c) ax)
           )
;; expected: true
